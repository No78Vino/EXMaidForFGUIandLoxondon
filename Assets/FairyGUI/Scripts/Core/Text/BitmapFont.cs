using System.Collections.Generic;
using UnityEngine;

namespace FairyGUI
{
    /// <summary>
    /// </summary>
    public class BitmapFont : BaseFont
    {
        private static Vector3 bottomLeft;
        private static Vector3 topLeft;
        private static Vector3 topRight;
        private static Vector3 bottomRight;

        private static readonly Color32[] vertexColors = new Color32[4];

        protected Dictionary<int, BMGlyph> _dict;
        protected BMGlyph _glyph;
        private float _scale;

        /// <summary>
        ///     Font generated by BMFont use channels.
        /// </summary>
        public bool hasChannel;

        /// <summary>
        /// </summary>
        public bool resizable;

        /// <summary>
        /// </summary>
        public int size;

        public BitmapFont()
        {
            canTint = true;
            hasChannel = false;
            customOutline = true;
            shader = ShaderConfig.bmFontShader;

            _dict = new Dictionary<int, BMGlyph>();
            _scale = 1;
        }

        public void AddChar(char ch, BMGlyph glyph)
        {
            _dict[ch] = glyph;
        }

        public override void SetFormat(TextFormat format, float fontSizeScale)
        {
            if (resizable)
                _scale = (float)format.size / size * fontSizeScale;
            else
                _scale = fontSizeScale;

            if (canTint)
                format.FillVertexColors(vertexColors);
        }

        public override bool GetGlyph(char ch, out float width, out float height, out float baseline)
        {
            if (ch == ' ')
            {
                width = Mathf.RoundToInt(size * _scale / 2);
                height = Mathf.RoundToInt(size * _scale);
                baseline = height;
                _glyph = null;
                return true;
            }

            if (_dict.TryGetValue(ch, out _glyph))
            {
                width = Mathf.RoundToInt(_glyph.advance * _scale);
                height = Mathf.RoundToInt(_glyph.lineHeight * _scale);
                baseline = height;
                return true;
            }

            width = 0;
            height = 0;
            baseline = 0;
            return false;
        }

        public override int DrawGlyph(float x, float y,
            List<Vector3> vertList, List<Vector2> uvList, List<Vector2> uv2List, List<Color32> colList)
        {
            if (_glyph == null) //space
                return 0;

            topLeft.x = x + _glyph.x * _scale;
            topLeft.y = y + (_glyph.lineHeight - _glyph.y) * _scale;
            bottomRight.x = x + (_glyph.x + _glyph.width) * _scale;
            bottomRight.y = topLeft.y - _glyph.height * _scale;

            topRight.x = bottomRight.x;
            topRight.y = topLeft.y;
            bottomLeft.x = topLeft.x;
            bottomLeft.y = bottomRight.y;

            vertList.Add(bottomLeft);
            vertList.Add(topLeft);
            vertList.Add(topRight);
            vertList.Add(bottomRight);

            uvList.AddRange(_glyph.uv);

            if (hasChannel)
            {
                var channel = new Vector2(_glyph.channel, 0);
                uv2List.Add(channel);
                uv2List.Add(channel);
                uv2List.Add(channel);
                uv2List.Add(channel);
            }

            if (canTint)
            {
                colList.Add(vertexColors[0]);
                colList.Add(vertexColors[1]);
                colList.Add(vertexColors[2]);
                colList.Add(vertexColors[3]);
            }
            else
            {
                colList.Add(Color.white);
                colList.Add(Color.white);
                colList.Add(Color.white);
                colList.Add(Color.white);
            }

            return 4;
        }

        public override bool HasCharacter(char ch)
        {
            return ch == ' ' || _dict.ContainsKey(ch);
        }

        public override int GetLineHeight(int size)
        {
            if (_dict.Count > 0)
                using (var et = _dict.GetEnumerator())
                {
                    et.MoveNext();
                    if (resizable)
                        return Mathf.RoundToInt((float)et.Current.Value.lineHeight * size / this.size);
                    return et.Current.Value.lineHeight;
                }

            return 0;
        }

        /// <summary>
        /// </summary>
        public class BMGlyph
        {
            public int advance;
            public int channel; //0-n/a, 1-r,2-g,3-b,4-alpha
            public float height;
            public int lineHeight;
            public Vector2[] uv = new Vector2[4];
            public float width;
            public float x;
            public float y;
        }
    }
}